# Tree-sitter Parser

## Overview

Tree-sitter is a parser generator tool and an incremental parsing library. It can build a concrete syntax tree for a source file and efficiently update the syntax tree as the source file is edited.

Our TreeSitterParser implementation wraps the py-tree-sitter library to provide:

- Multi-language parsing support
- Incremental parsing
- Error recovery
- Advanced query capabilities

## Version Compatibility

- LANGUAGE_VERSION = 14 (Latest ABI version supported)
- MIN_COMPATIBLE_LANGUAGE_VERSION = 13

Note: When a Language is generated by the Tree-sitter CLI, it is assigned an ABI version number.
The library is backwards-compatible with older CLI versions, but not forwards-compatible.

## Installation

### Dependencies

Install the package with all dependencies:

```bash
# Install package with all dependencies
pip install -e ".[dev]"
```

This will install:

- tree-sitter core library
- Language-specific parsers:
  - tree-sitter-python>=0.23.6
  - tree-sitter-javascript>=0.23.1
  - tree-sitter-typescript>=0.23.2
  - tree-sitter-java>=0.23.5
  - tree-sitter-cpp>=0.23.4
  - tree-sitter-go>=0.23.4
  - tree-sitter-ruby>=0.23.1
  - tree-sitter-php>=0.23.11
  - tree-sitter-c>=0.23.4
  - tree-sitter-c-sharp>=0.23.1
  - tree-sitter-scala>=0.23.4
  - tree-sitter-kotlin>=1.0.1
  - tree-sitter-lua>=0.2.0
  - tree-sitter-bash>=0.23.3
  - tree-sitter-html>=0.23.2
  - tree-sitter-css>=0.23.1
  - tree-sitter-json>=0.24.8
  - tree-sitter-yaml>=0.7.0
  - tree-sitter-toml>=0.7.0
  - tree-sitter-xml>=0.7.0
  - tree-sitter-markdown>=0.3.2
  - tree-sitter-sql>=0.3.7
  - tree-sitter-arduino>=0.23.0
  - tree-sitter-cuda>=0.20.6
  - tree-sitter-groovy>=0.1.2
  - tree-sitter-matlab>=1.0.2

### Special Language Handling

Some languages require special handling:

### TypeScript/JavaScript

```python
# TypeScript has separate parsers for TS and TSX
from tree_sitter import Language, Parser

# For TypeScript
TS_LANGUAGE = Language(tree_sitter_typescript.language(), "typescript")

# For TSX
TSX_LANGUAGE = Language(tree_sitter_typescript.language(), "tsx")
```

### Language Loading Patterns

There are three main patterns for loading languages:

1. Direct loading (most languages):

```python
PY_LANGUAGE = Language(tree_sitter_python.language())
```

1. Named variant loading (TypeScript):

```python
TS_LANGUAGE = Language(tree_sitter_typescript.language(), "typescript")
```

1. Multiple parser loading (some languages with variants):

```python
# Example with multiple parsers
parser.language = TS_LANGUAGE  # For .ts files
tsx_parser.language = TSX_LANGUAGE  # For .tsx files
```

### Error Handling

Common initialization errors:

- `AttributeError: module has no attribute 'language'` - Language module not properly installed
- `ParserError: Language not supported` - Language not in configured list
- `ImportError: No module named 'tree_sitter_<lang>'` - Language package not installed

### Manual Language Installation

If you need to install language support separately:

```bash
pip install tree-sitter-python==0.23.6
pip install tree-sitter-javascript==0.23.1
pip install tree-sitter-typescript==0.23.2
# etc...
```

Note: Some language packages provide multiple parsers. For example:

- tree-sitter-typescript provides both TypeScript and TSX parsers
- tree-sitter-javascript provides both JavaScript and JSX parsers

Note: We no longer build languages from source - we use pre-built packages instead.

## Parser Usage

### Basic Initialization

```python
from tree_sitter import Language, Parser
import tree_sitter_python

# Create and initialize language
PY_LANGUAGE = Language(tree_sitter_python.language())

# Create parser and set language
parser = Parser()
parser.set_language(PY_LANGUAGE)
```

### Parsing Options

The parser supports different input methods:

1. Direct bytes:

```python
tree = parser.parse(bytes("def hello(): pass", "utf8"))
```

1. Custom read function with byte offset:

```python
def read_source(byte_offset, point):
    return source[byte_offset:byte_offset + 1]

tree = parser.parse(read_source, encoding="utf8")
```

### Error Recovery

Tree-sitter attempts to recover from errors by:

- Creating ERROR nodes for invalid syntax
- Continuing parsing after errors
- Maintaining tree structure where possible

### Performance Optimization

```python
# Set timeout for long parses
parser.timeout_micros = 5000  # 5ms timeout

# Set included ranges for partial parsing
parser.included_ranges = [(start_byte, end_byte)]
```

### Incremental Parsing

When source code is edited:

```python
# Edit the tree
tree.edit(
    start_byte=5,
    old_end_byte=5,
    new_end_byte=7,
    start_point=(0, 5),
    old_end_point=(0, 5),
    new_end_point=(0, 7)
)

# Parse with previous tree
new_tree = parser.parse(new_source, old_tree)
```

### Query Patterns

```python
query = language.query("""
    (function_definition
        name: (identifier) @function.name
        parameters: (parameters) @function.params
        body: (block) @function.body)
""")

# Get captures
captures = query.captures(root_node)

# Get matches
matches = query.matches(root_node)
```

## References

- [Tree-sitter Documentation](https://tree-sitter.github.io/tree-sitter/)
- [py-tree-sitter README](https://github.com/tree-sitter/py-tree-sitter)
- [Tree-sitter Playground](https://tree-sitter.github.io/tree-sitter/playground)
