# Tree-sitter Parser

## Overview

Tree-sitter is a parser generator tool and an incremental parsing library. It can build a concrete syntax tree for a source file and efficiently update the syntax tree as the source file is edited.

Our TreeSitterParser implementation wraps the py-tree-sitter library to provide:

- Multi-language parsing support
- Incremental parsing
- Error recovery
- Advanced query capabilities

## Version Compatibility

- LANGUAGE_VERSION = 14 (Latest ABI version supported)
- MIN_COMPATIBLE_LANGUAGE_VERSION = 13

Note: When a Language is generated by the Tree-sitter CLI, it is assigned an ABI version number.
The library is backwards-compatible with older CLI versions, but not forwards-compatible.

## Installation

### Dependencies

Install the package with all dependencies:

```bash
# Install package with all dependencies
pip install -e ".[dev]"
```

This will install:

- tree-sitter core library
- Language-specific parsers:
  - tree-sitter-python>=0.23.6
  - tree-sitter-javascript>=0.23.1
  - tree-sitter-typescript>=0.23.2
  - tree-sitter-java>=0.23.5
  - tree-sitter-cpp>=0.23.4
  - tree-sitter-go>=0.23.4
  - tree-sitter-ruby>=0.23.1
  - tree-sitter-php>=0.23.11
  - tree-sitter-c>=0.23.4
  - tree-sitter-c-sharp>=0.23.1
  - tree-sitter-scala>=0.23.4
  - tree-sitter-kotlin>=1.0.1
  - tree-sitter-lua>=0.2.0
  - tree-sitter-bash>=0.23.3
  - tree-sitter-html>=0.23.2
  - tree-sitter-css>=0.23.1
  - tree-sitter-json>=0.24.8
  - tree-sitter-yaml>=0.7.0
  - tree-sitter-toml>=0.7.0
  - tree-sitter-xml>=0.7.0
  - tree-sitter-markdown>=0.3.2
  - tree-sitter-sql>=0.3.7
  - tree-sitter-arduino>=0.23.0
  - tree-sitter-cuda>=0.20.6
  - tree-sitter-groovy>=0.1.2
  - tree-sitter-matlab>=1.0.2

### Special Language Handling

Some languages require special handling:

### TypeScript/JavaScript Special Cases

TypeScript and JavaScript have multiple language variants that need special handling:

```python
# TypeScript requires explicit language type
import tree_sitter_typescript

# Initialize both TypeScript and TSX from the same module
try:
    # Get both TS and TSX parsers from typescript module
    ts_language = Language(language_module.language_typescript())
    tsx_language = Language(language_module.language_tsx())

    # Create parsers for both
    ts_parser = TSParser()
    tsx_parser = TSParser()

    ts_parser.language = ts_language
    tsx_parser.language = tsx_language
except AttributeError:
    raise ParserError("Failed to initialize TypeScript: no valid language loader found")
```

### Language Loading Strategies

There are three main patterns for loading languages:

1. Direct loading (most languages):

```python
PY_LANGUAGE = Language(tree_sitter_python.language())
```

1. Named variant loading (TypeScript):

```python
TS_LANGUAGE = Language(tree_sitter_typescript.language_typescript())
```

1. Multiple parser loading (some languages with variants):

```python
# Example with multiple parsers
ts_parser = Parser()
ts_parser.language = Language(tree_sitter_typescript.language_typescript())

tsx_parser = Parser()
tsx_parser.language = Language(tree_sitter_typescript.language_tsx())
```

### Error Handling

Tree-sitter provides several types of error handling:

1. Parse Errors:

```python
try:
    tree = parser.parse(bytes(source_code, "utf8"))
    if tree.root_node.has_error:
        # Handle syntax errors
        print("Syntax errors found")
except Exception as e:
    print(f"Parse failed: {e}")
```

1. Node Error Detection:

```python
def check_errors(node):
    # Check if node itself is an error
    if node.is_error:
        return True

    # Check if node contains errors
    if node.has_error:
        return True

    return False
```

1. Missing Nodes:

```python
# Missing nodes are inserted by the parser for error recovery
if node.is_missing:
    print(f"Missing node at {node.start_point}")
```

1. Extra Nodes:

```python
# Extra nodes represent things like whitespace
if node.is_extra:
    print(f"Extra node: {node.type}")
```

### Common Error Types

- `ParserError`: Base error for parsing failures
- `ImportError`: When language module can't be imported
- `AttributeError`: When language module doesn't provide expected methods
- `ValueError`: For invalid inputs or configurations

Common initialization errors:

- `AttributeError: module has no attribute 'language'` - Language module not properly installed or requires special loading (e.g., TypeScript)
- `ParserError: Language not supported` - Language not in configured list
- `ImportError: No module named 'tree_sitter_<lang>'` - Language package not installed
- `TypeError: __init__() takes exactly N arguments` - Incorrect language initialization

### Manual Language Installation

If you need to install language support separately:

```bash
pip install tree-sitter-python==0.23.6
pip install tree-sitter-javascript==0.23.1
pip install tree-sitter-typescript==0.23.2
# etc...
```

Note: Some language packages provide multiple parsers. For example:

- tree-sitter-typescript provides both TypeScript and TSX parsers
- tree-sitter-javascript provides both JavaScript and JSX parsers

Note: We no longer build languages from source - we use pre-built packages instead.

### Basic Initialization

```python
from tree_sitter import Language, Parser
import tree_sitter_python

# Create and initialize language
PY_LANGUAGE = Language(tree_sitter_python.language())

# Create parser and set language
parser = Parser()
parser.language = PY_LANGUAGE
```

### Parser Configuration

The Parser class supports several configuration options:

```python
parser = Parser()

# Set timeout for parsing (in microseconds)
parser.timeout_micros = 5000  # 5ms timeout

# Set included ranges for partial parsing
parser.included_ranges = [(start_byte, end_byte)]

# Set logger for debugging
parser.logger = custom_logger  # Added in version 0.24.0

# Print DOT graphs for debugging
parser.print_dot_graphs(file_descriptor)  # Added in version 0.24.0
```

### Parsing Options

The parser supports different input methods:

1. Direct bytes:

```python
tree = parser.parse(bytes("def hello(): pass", "utf8"))
```

1. Custom read function with byte offset:

```python
def read_source(byte_offset, point):
    return source[byte_offset:byte_offset + 1]

tree = parser.parse(read_source, encoding="utf8")
```

1. Parse with previous tree (incremental parsing):

```python
new_tree = parser.parse(new_source, old_tree)
```

### Error Recovery

Tree-sitter attempts to recover from errors by:

- Creating ERROR nodes for invalid syntax
- Continuing parsing after errors
- Maintaining tree structure where possible

Error nodes can be detected using:

```python
# Check if node represents a syntax error
if node.is_error:
    handle_error_node(node)

# Check if node contains any syntax errors
if node.has_error:
    handle_node_with_errors(node)
```

### Performance Optimization

Tree-sitter provides two main mechanisms for handling large files:

1. Timeout Control:

```python
# Set timeout for long parses (in microseconds)
parser.timeout_micros = 5000  # 5ms timeout
```

1. Partial Parsing:

```python
# Only parse specific ranges of a file
parser.included_ranges = [(start_byte, end_byte)]
```

#### Handling Large Files

Tree-sitter doesn't define a specific threshold for "large" files. Instead:

- It attempts to parse entire files by default
- Use `included_ranges` when you want to parse specific sections:

  ```python
  # Example: Only parse first 1000 bytes
  parser.included_ranges = [(0, 1000)]

  # Example: Parse multiple ranges
  parser.included_ranges = [
      (0, 1000),      # First 1000 bytes
      (5000, 6000),   # Another section
  ]
  ```

- Use `timeout_micros` to prevent hanging on complex files:

  ```python
  # Stop parsing if it takes more than 5ms
  parser.timeout_micros = 5000

  # If parsing times out, you can:
  # 1. Try again with a longer timeout
  # 2. Use included_ranges to parse smaller sections
  # 3. Use reset() to clear parser state
  parser.reset()
  ```

Note: Unlike some other parsers, tree-sitter doesn't require a maximum file size limit
since it can efficiently handle large files through timeouts and partial parsing.
If you need to limit file sizes, it's better to do it at the file reading level
rather than the parsing level.

### Incremental Parsing

When source code is edited:

```python
# Get original tree
old_tree = parser.parse(bytes(original_source, "utf8"))

# Edit the tree
tree.edit(
    start_byte=5,
    old_end_byte=5,
    new_end_byte=7,
    start_point=(0, 5),
    old_end_point=(0, 5),
    new_end_point=(0, 7)
)

# Parse with previous tree
new_tree = parser.parse(new_source, old_tree)

# Check what changed
for changed_range in old_tree.changed_ranges(new_tree):
    print(f"Changed range: {changed_range.start_point} to {changed_range.end_point}")
```

### Query Patterns

```python
query = language.query("""
    (function_definition
        name: (identifier) @function.name
        parameters: (parameters) @function.params
        body: (block) @function.body)
""")

# Get captures
captures = query.captures(root_node)

# Get matches
matches = query.matches(root_node)
```

## References

- [Tree-sitter Documentation](https://tree-sitter.github.io/tree-sitter/)
- [py-tree-sitter README](https://github.com/tree-sitter/py-tree-sitter)
- [Tree-sitter Playground](https://tree-sitter.github.io/tree-sitter/playground)

### Language Loading Patterns

#### Test Setup Best Practices

When writing tests, ensure all required languages are initialized:

```python
@pytest.fixture
def parser() -> Generator[TreeSitterParser, None, None]:
    parser = TreeSitterParser()
    # Initialize all languages needed for tests
    parser.initialize([
        "python", "javascript", "typescript",
        "css", "yaml", "json", "bash", "cpp",
        "java", "html"
    ])
    yield parser
    parser.cleanup()

#### Language Support Verification

Always verify language support before parsing:

```python
def parse(self, content: str, language: str) -> ParseResult:
    if not self.initialized:
        raise ParserError("Parser not initialized")

    if language not in self._parsers:
        raise ParserError(f"Language {language} not supported")

    # Continue with parsing...
```

#### File Type Handling

When parsing files, handle all error cases:

```python
def parse_file(self, file_path: Union[str, Path]) -> ParseResult:
    try:
        path = validate_file_path(file_path)
        if not path.exists():
            raise ParserError(f"File not found: {path}")

        if is_binary_file(str(path)):
            raise ParserError(f"File {path} is not a text file")

        language = self._get_language_for_file(path)
        if not language:
            raise ParserError(f"Unsupported file extension: {path.suffix}")

        # Continue with parsing...
    except Exception as e:
        raise ParserError(f"Failed to parse file {file_path}: {str(e)}")

### Error Recovery and AST Analysis

Tree-sitter provides robust error recovery capabilities, allowing partial analysis even when code contains syntax errors:

```python
def analyze_with_errors(content: str) -> Dict[str, Any]:
    result = parser.parse(content, "python")

    # Even with errors, we get a parse tree
    if result.ast is not None:
        # Check for errors
        if not result.is_valid:
            print(f"Found {len(result.errors)} errors")

        # Extract valid functions even from invalid code
        functions = result.metadata["analysis"]["functions"]
        return functions
```

#### Function Analysis with Error Recovery

When analyzing functions, handle error nodes properly:

```python
def get_functions(node: Node) -> Dict[str, Dict[str, int]]:
    """Extract function definitions from AST."""
    functions = {}

    # Handle error recovery - process nodes even with errors
    if node.type == "function_definition":
        # Get function name even if there are errors
        name_node = node.child_by_field_name("name")
        if name_node and name_node.type == "identifier":
            functions[name_node.text.decode('utf8')] = {
                'start': name_node.start_point[0],
                'end': name_node.end_point[0]
            }

    # Process all children, including error nodes
    for child in node.children:
        child_functions = get_functions(child)
        functions.update(child_functions)

    return functions
```

#### AST Node Properties

Important node properties for error handling:

- `node.has_error`: True if node or any descendants contain errors
- `node.is_error`: True if node itself is an error node
- `node.is_missing`: True if node was inserted for error recovery
- `node.child_by_field_name()`: Get child node by field name (more reliable than index)

#### Best Practices for Error Recovery

1. Don't skip error nodes during traversal
2. Use field names instead of indices to access node children
3. Validate node types before processing
4. Handle partial ASTs gracefully

### Language Initialization (Part 1)

```python
def initialize_languages(languages: Optional[List[str]] = None) -> None:
    """Initialize parsers for multiple languages."""
    # Start with core languages if none specified
    languages = languages or ["python", "javascript", "typescript"]

    for lang in languages:
        try:
            # Import language module
            module_name = f"tree_sitter_{lang}"
            language_module = __import__(module_name)

            # Initialize parser
            language = Language(language_module.language())
            parser = Parser()
            parser.language = language

        except ImportError:
            raise ParserError(f"Language {lang} not installed")
        except Exception as e:
            raise ParserError(f"Failed to initialize {lang}: {e}")

### Handling File Types

When parsing files, handle all error cases:

```python
def parse_file(file_path: Union[str, Path]) -> ParseResult:
    try:
        # Validate path
        path = validate_file_path(file_path)

        # Check file type
        if is_binary_file(str(path)):
            raise ParserError(f"File {path} is not a text file")

        # Get language from extension
        language = get_language_for_file(path)
        if not language:
            raise ParserError(f"Unsupported extension: {path.suffix}")

        # Parse content
        with open(path, 'r', encoding='utf8') as f:
            content = f.read()
        return parse(content, language)

    except Exception as e:
        raise ParserError(f"Failed to parse {file_path}: {e}")

### Error Recovery

Tree-sitter follows these key principles for error handling:

1. Creates ERROR nodes for syntax errors:

```python
if node.type == "ERROR":
    # This node represents a syntax error
    print(f"Error at line {node.start_point[0]}")
```

1. Continues parsing after errors:

```python
# Even with errors, parsing continues
if node.has_error:
    # Node or its children contain errors
    # But we can still process valid parts
    for child in node.children:
        process_valid_parts(child)
```

1. Identifies valid constructs after errors:

```python
# Example: Finding valid functions even after syntax errors
if (node.type == "function_definition" or
    (node.type == "def" and node.next_sibling and
     node.next_sibling.type == "identifier")):
    # Process function even if previous code had errors
    process_function(node)
```

#### Tree Traversal with Errors

Tree-sitter provides two ways to traverse the syntax tree:

1. Direct child traversal:

```python
# Simple but less reliable with errors
for child in node.children:
    process_node(child)
```

1. Cursor traversal (recommended):

```python
# More reliable, especially with error nodes
cursor = node.walk()

def visit(cursor: TreeCursor) -> None:
    # Process current node
    process_node(cursor.node)

    # Visit all children
    if cursor.goto_first_child():
        visit(cursor)
        cursor.goto_parent()

    # Visit next sibling
    if cursor.goto_next_sibling():
        visit(cursor)

visit(cursor)
```

#### Node Positions and Error Recovery

When working with error nodes:

```python
# Get positions from the function node, not the name node
if node.type == "function_definition":
    name_node = node.child_by_field_name("name")
    if name_node and name_node.type == "identifier":
        function_info = {
            'start': node.start_point[0],  # Use function node position
            'end': node.end_point[0],
            'name': name_node.text.decode('utf8')
        }
```

Key points:

- Use TreeCursor for reliable error node traversal
- Get positions from parent nodes when possible
- Always check node types before accessing fields
- Have a fallback strategy for cursor traversal failures

### Language Initialization

#### Language-Specific Initialization (Part 2)

Different languages expose their parsers in different ways:

1. Standard Languages:

```python
# Most languages use the standard pattern
language = Language(language_module.language())
```

1. TypeScript (Multiple Variants):

```python
# TypeScript provides both TS and TSX parsers
ts_language = Language(language_module.language_typescript())
tsx_language = Language(language_module.language_tsx())
```

1. JavaScript (Multiple Variants):

```python
# JavaScript provides both JS and JSX parsers
js_language = Language(language_module.language())
jsx_language = Language(language_module.language_jsx())
```

1. PHP (Custom Loader):

```python
# PHP uses get_language() instead of language()
language = Language(language_module.get_language())
```

1. Ruby (Embedded Languages):

```python
# Ruby supports embedded languages and uses get_parser()
language = Language(language_module.get_parser())
```

#### Language Variants and Embedded Support

Some languages have special features:

1. Multiple Syntax Variants:

- TypeScript: TS and TSX for React
- JavaScript: JS and JSX for React
- C++: Different standards (C++11, C++14, etc.)

1. Embedded Language Support:

- Ruby: Can contain embedded JavaScript, CSS, etc.
- PHP: Can contain HTML, JavaScript, CSS
- HTML: Can contain JavaScript, CSS

1. Special Initialization Requirements:

```python
def initialize_language(lang: str) -> None:
    try:
        module = __import__(f"tree_sitter_{lang}")

        # Handle special cases
        if lang == "typescript":
            return module.language_typescript()  # or language_tsx()
        elif lang == "javascript":
            return module.language()  # or language_jsx()
        elif lang == "php":
            return module.get_language()
        elif lang == "ruby":
            return module.get_parser()

        # Standard case
        return module.language()
    except AttributeError as e:
        raise ParserError(f"Failed to initialize {lang}: {e}")

#### Best Practices for Language Support

1. Always check for language-specific initialization methods
2. Handle multiple variants when available
3. Consider embedded language support
4. Provide fallback for standard initialization
5. Log initialization details for debugging

### Tree Traversal with Errors

Tree-sitter provides two ways to traverse the syntax tree:

#### Cursor-Based Traversal

TreeCursor is the recommended way to traverse syntax trees because:

1. Maintains state about position in tree:

```python
cursor = node.walk()
# Cursor remembers where it is in the tree
if cursor.goto_first_child():
    process_node(cursor.node)
    cursor.goto_parent()  # Can return to parent
```

1. Ensures accurate current node access:

```python
def visit(cursor: TreeCursor) -> None:
    # cursor.node always gives us the current node
    current = cursor.node
    print(f"At node: {current.type}")
```

1. Critical for error recovery:

```python
# Even when node relationships are broken by errors
if cursor.node.has_error:
    # Can still navigate reliably
    if cursor.goto_next_sibling():
        process_valid_node(cursor.node)
```

1. Reliable navigation through errors:

```python
# TreeCursor can navigate past error nodes
def visit(cursor: TreeCursor) -> None:
    if cursor.node.type == "ERROR":
        # Skip error node but continue traversal
        if cursor.goto_next_sibling():
            visit(cursor)
    else:
        process_node(cursor.node)
```

1. Direct child traversal:

```python
# Simple but less reliable with errors
for child in node.children:
    process_node(child)
```

1. Cursor traversal (recommended):

```python
# More reliable, especially with error nodes
cursor = node.walk()

def visit(cursor: TreeCursor) -> None:
    # Process current node
    process_node(cursor.node)

    # Visit all children
    if cursor.goto_first_child():
        visit(cursor)
        cursor.goto_parent()

    # Visit next sibling
    if cursor.goto_next_sibling():
        visit(cursor)

visit(cursor)
```

#### Language-Specific Initialization

Different languages expose their parsers in different ways:

1. Standard Languages:

```python
# Most languages use the standard pattern
language = Language(language_module.language())
```

1. TypeScript (Multiple Variants):

```python
# TypeScript provides both TS and TSX parsers
ts_language = Language(language_module.language_typescript())
tsx_language = Language(language_module.language_tsx())
