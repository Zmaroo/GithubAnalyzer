I'll check the repositories for each failing language to find the correct node types:
Swift (https://github.com/alex-pinkus/tree-sitter-swift)
Current pattern: (function), (method), (closure)
Should be: (function_declaration), (function_definition), (closure_expression)
Groovy (https://github.com/Decodetalkers/tree-sitter-groovy)
Current pattern: (method), (constructor), (closure)
Should be: (method_definition), (constructor_definition), (closure_expression)
Zig (https://github.com/maxxnino/tree-sitter-zig)
Current pattern: (fn)
Should be: (FnProto), (FnDecl) (note: case sensitive)
CommonLisp (https://github.com/theHamsta/tree-sitter-commonlisp)
Current pattern: (defun), (lambda)
Should be: (list) with pattern matching
Erlang (https://github.com/WhatsApp/tree-sitter-erlang)
Current pattern: (fun), (function)
Should be: (fun_expr), (function_clause)
PureScript (https://github.com/postsolar/tree-sitter-purescript)
Current pattern: (value), (lambda)
Should be: (value_declaration), (lambda_expression)
Dart (https://github.com/UserNobody14/tree-sitter-dart)
Current pattern: (function), (method), (lambda)
Should be: (function_signature), (method_signature), (lambda_expression)
Hack (https://github.com/slackhq/tree-sitter-hack)
Current pattern: (function), (method), (lambda)
Should be: (function_declaration_header), (method_declaration_header), (anonymous_function_expression)
Haxe (https://github.com/vantreeseba/tree-sitter-haxe)
Current pattern: (function), (method), (arrow)
Should be: (function_declaration_with_body), (method_declaration_with_body), (arrow_function_expression)
V (https://github.com/nedpals/tree-sitter-v)
Current pattern: (fn), (method)
Should be: (fn_declaration), (method_declaration), (anon_fn)
Gleam (https://github.com/gleam-lang/tree-sitter-gleam)
Current pattern: (fn)
Should be: (fn_expr), (fn_decl)

Ok, swift pattern starts at line 1223

FunctionDecl", "InitializerDecl", and "DeinitializerDecl". 

Groovy:
The actual function-related node type is func, not method_declaration
We also have block and command nodes that might be relevant
Racket:
We have list nodes as expected
Functions are represented as lists with specific symbols
We also have symbol nodes for function names
Clojure:
We have list_lit nodes as expected
We also have sym_lit and sym_name for symbols
Functions are represented as list literals with specific symbols