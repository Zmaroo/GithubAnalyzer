# Cursor Rules for GitHub Analyzer

This project aims to be a tool that an AI model/agent can use to gain deep knowledge and insights about Github repositories and code bases.

## Directory Structure and Guidelines

### Source Code (`src/GithubAnalyzer/`)

#### `models/` - Data Models and Domain Objects
- Data structures and their relationships
- No business logic or implementations
- Only data validation and basic utility methods

##### `models/core/` - Core Domain Models
- Fundamental domain models and base classes that other models depend on
- Should contain ONLY:
  - `base.py` - Base model classes and interfaces (e.g., `BaseModel`)
  - `errors.py` - Core exception classes and error definitions
  - `types.py` - Core type definitions and enums
  - `config.py` - Configuration model definitions
  - `repository.py` - Core repository and project models
- Should NOT contain:
  - Analysis-specific models (move to analysis/)
  - Service-specific models (move to respective service domains)
  - Implementation details
  - Business logic

##### `models/analysis/` - Analysis Domain Models
- Models specific to code analysis and results
- Should contain ONLY:
  - `results.py` - Analysis result models and containers
  - `metrics.py` - Pure metric definitions and thresholds
  - `patterns.py` - Pattern definitions and rules
  - `relationships.py` - Relationship type definitions
  - `ast.py` - Abstract Syntax Tree models
- Should NOT contain:
  - Parser implementations (belongs in services)
  - Analysis logic (belongs in services)
  - Generic utility models (belongs in core)
  - Configuration (belongs in config)

#### `services/` - Business Logic and Implementations
- Service implementations and business logic
- Uses models to represent data
- Contains actual functionality and algorithms
- Examples:
  - `core/` - Core service implementations
  - `analysis/` - Analysis implementations using analysis models
  - `storage/` - Database and storage implementations

#### `config/` - Configuration Management
- Application settings and configuration
- Environment-specific settings
- Language and framework configurations
- Examples:
  - `settings.py` - Main application settings
  - `language_config.py` - Language-specific configuration

#### `utils/` - Utility Functions
- Shared utility functions
- Helper methods used across services
- No business logic or models
- Examples:
  - Logging utilities
  - File operations
  - String manipulation

#### `types/` - Type Definitions
- Custom type definitions
- Type aliases and protocols
- Shared type utilities
- No implementations, only type definitions

### Anti-Redundancy Rules

1. **Before Adding New Code**:
   - Check existing models in `models/` for similar data structures
   - For foundational models, check `models/core/` first
   - For analysis-specific models, check `models/analysis/` first
   - Search for similar utility functions in `utils/`
   - Review configuration in `config/` for related settings

2. **Model Guidelines**:
   - Core models:
     - Must inherit from `BaseModel`
     - Should be domain-agnostic
     - Should define interfaces and contracts
     - Should be highly reusable
   - Analysis models:
     - Must be specific to code analysis domain
     - Should represent analysis artifacts
     - Should focus on data structures, not behavior
     - Should use core models as building blocks
   - No duplicate model definitions
   - Use inheritance from core base classes

3. **Service Guidelines**:
   - Implementation logic goes ONLY in `services/`
   - Services should use models from `models/`
   - No business logic in models
   - No duplicate service implementations

4. **Configuration Guidelines**:
   - All settings in `config/settings.py`
   - Language config in `config/language_config.py`
   - Framework patterns in `models/analysis/patterns.py`
   - No scattered configuration files

5. **Type Guidelines**:
   - Custom types go in `types/`
   - No duplicate type definitions
   - Use type aliases for common types
   - Keep type definitions DRY

### Testing Requirements

### Tree-sitter Parser Testing

The tree-sitter parser implementation is a critical component. Any changes to these files require running parser tests:

- `src/GithubAnalyzer/services/core/parsers/tree_sitter.py`
- `src/GithubAnalyzer/services/core/parsers/base.py` (if changes affect tree-sitter)
- Any files modifying tree-sitter query patterns or language configurations

To verify changes:
```bash
pytest tests/test_parsers -v
```

## Tree-sitter Language Support

This project uses pre-built tree-sitter language parsers installed via pip. The supported languages are defined in `config/language_config.py`. To add support for a new language:

1. Install the corresponding tree-sitter parser package
2. Add the language mapping to `TREE_SITTER_LANGUAGES` in `language_config.py`
3. Add appropriate query patterns in `tree_sitter.py`
4. Add tests for the new language parser

## Import Rules

Always use absolute imports. For example:
```python
from GithubAnalyzer.models.core.errors import ParseError
```

## Configuration Management

1. All application settings must be defined in `config/settings.py`
2. Import settings from `config/__init__.py`, not directly from `settings.py`
3. Language-specific configuration belongs in `language_config.py`
4. Framework patterns belong in `models/analysis/patterns.py`

## Best Practices

1. Keep models and services separate
   - Models go in `models/`
   - Services go in `services/`
   - No models in services directory

2. Configuration Management
   - Use `ConfigurableService` base class for services needing configuration
   - Validate all configuration in `_validate_config` method
   - Don't modify configuration after service initialization

3. Error Handling
   - Use appropriate error classes from `models/core/errors.py`
   - Add new error types to the core errors module if needed
   - Include meaningful error messages

4. Testing
   - Write tests for all new functionality
   - Organize tests by type (unit, integration, parsers)
   - Ensure all tests pass before committing

5. Code Quality
   - Run pre-commit hooks before committing
   - Fix all linting and type checking errors
   - Keep functions and methods focused and well-documented

6. Preventing Redundancy
   - Search existing code before creating new files
   - Use inheritance and composition over duplication
   - Consolidate similar functionality
   - Keep code DRY (Don't Repeat Yourself)

### Directory Organization Rules

1. **Core Services (`services/core/`)**:
   - Only foundational service implementations
   - Base classes for other services
   - Core infrastructure (DI, configuration, registry)
   - Parser implementations
   - No domain-specific business logic

2. **Analysis Models (`models/analysis/`)**:
   - Only analysis-specific data structures
   - Result definitions
   - Metric and pattern specifications
   - No implementations or algorithms
   - No generic code structures

3. **Service Organization**:
   - Database operations → `services/storage/`
   - Query processing → `services/query/`
   - Repository management → `services/repository/`
   - Analysis execution → `services/analysis/`
   - Core infrastructure → `services/core/`
