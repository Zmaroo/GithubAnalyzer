# Cursor Rules for GitHub Analyzer

This project aims to be a tool that an AI model/agent can use to gain deep knowledge and insights about Github repositories and code bases.

## Testing Requirements

### Tree-sitter Parser Testing

The tree-sitter parser implementation is a critical component of this project. Any changes to the following files/directories must be verified by running the parser tests:

- `src/GithubAnalyzer/services/core/parsers/tree_sitter.py`
- `src/GithubAnalyzer/services/core/parsers/base.py` (if changes affect tree-sitter implementation)
- Any files that modify tree-sitter query patterns or language configurations
- `scripts/build_tree_sitter.py` (script for building tree-sitter language grammars)

To verify changes:

```bash
pytest tests/test_parsers -v
```

All parser tests must pass before changes can be committed.

If modifying supported languages or grammar configurations:

1. Run `python scripts/build_tree_sitter.py` to rebuild language grammars
2. Run the parser tests to verify the changes

## Import Rules

Always use absolute imports in this project. For example:

```python
from GithubAnalyzer.models.core.errors import ParseError
```

This makes the code more maintainable and follows Python best practices.

## Project Structure

The project follows this structure:

### Source Code

- src/GithubAnalyzer/
  - models/     - Data models and domain objects
  - services/   - Business logic and services
  - utils/      - Utility functions and helpers
  - config/     - Configuration management
  - types/      - Type definitions

### Tests

- tests/
  - unit/           - Unit tests
  - integration/    - Integration tests
  - performance/    - Performance tests
  - security/       - Security tests
  - test_parsers/   - Parser-specific tests

## Core Files

- pyproject.toml         - Project metadata and dependencies
- pytest.ini            - Test configuration
- .pre-commit-config.yaml - Git hooks for code quality
- .cursorrules.md       - Development guidelines

## Best Practices

1. Verify project structure before making changes
2. Check existing files to avoid duplication
3. Use documentation when encountering errors
4. Follow test organization by type (unit, integration, etc.)
